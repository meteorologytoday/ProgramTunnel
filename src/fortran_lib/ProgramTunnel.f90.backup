module ProramTunnelMod
implicit none

integer, parameter :: send_txt = 1, recv_txt = 2, send_bin = 3, recv_bin = 4
character(len=256), parameter :: keys(4) = (/"X2Y_txt", "Y2X_txt", "X2Y_bin", "Y2X_bin"/)

type ptm_Tunnel
    Integer :: next_ptr
    Integer :: fds(2)
    character(len=256) :: fns(2)
end type


type ptm_TunnelSet
    type(ptm_Tunnel) :: tnls(4)
end type


contains

integer function ptm_get_file_unit()
    
    integer :: lu, iostat
    logical :: opened
      
    do lu = 999, 1,-1
       inquire (unit=lu, opened=opened, iostat=iostat)
       if (iostat.ne.0) cycle
       if (.not.opened) exit
    end do
    
    ptm_get_file_unit = lu
    return
end function 

subroutine ptm_makeFilename(filename, id, n)
    implicit none
    character(len=*) filename, id
    integer :: n

    write (filename, '(A, A, A, I1, A)'), "_", id, "_", n, ".fifo"

end subroutine

subroutine ptm_setDefault(ptm_TunnelSet)
    implicit none
    type(ptm_TunnelSet) :: TS
    integer :: i
    do i = 1, 4
        do j = 1, 2
            call ptm_makeFilename(TS%tnls(i)%fns(j), keys(i), j)
            TS%tnls(i)%fds(j) = ptm_get_file_unit()
        end do
    end do

end subroutine 


subroutine ptm_appendPath(MI, path)
    implicit none
    type(ptm_ptm_TunnelSet) :: MI
    character(len=256) :: path

    MI%recv_txt_fn  = path // "/" // MI%recv_txt_fn 
    MI%send_txt_fn  = path // "/" // MI%send_txt_fn
    MI%recv_bin_fn  = path // "/" // MI%recv_bin_fn 
    MI%send_bin_fn  = path // "/" // MI%send_bin_fn 
 
    MI%log_file = path // "/" // MI%log_file

end subroutine 

integer function ptm_recv_txt(MI, msg)
    implicit none
    type(ptm_ptm_TunnelSet)  :: MI
    character(len=*)       :: msg
    
    logical :: file_exists

    ptm_recv_txt = 0
    open(unit=MI%recv_txt_fd, file=MI%recv_txt_fn, form="formatted", access="stream", action="read", iostat=ptm_recv_txt)
    if (ptm_recv_txt .gt. 0) then
        print *, "ERROR OPENING RECV TXT PIPE, errcode:", ptm_recv_txt
        close(MI%recv_txt_fd)
        return
    end if

    ptm_recv_txt = 0
    read (MI%recv_txt_fd, '(A)', iostat=ptm_recv_txt) msg
    if (ptm_recv_txt .gt. 0) then
        print *, msg
        print *, "ERROR READING RECV TXT PIPE, errcode:", ptm_recv_txt
        close(MI%recv_txt_fd)
        return
    end if

    close(MI%recv_txt_fd)
    
    msg = trim(msg)

end function


integer function ptm_send_txt(MI, msg)
    implicit none
    type(ptm_ptm_TunnelSet)  :: MI
    character(len=*)       :: msg

    ptm_send_txt = 0
    open(unit=MI%send_txt_fd, file=MI%send_txt_fn, form="formatted", access="stream", action="write", iostat=ptm_send_txt)
    if (ptm_send_txt .gt. 0) then
        print *, "[ptm_send] Error during open."
        close(MI%send_txt_fd)
        return
    end if

    ptm_send_txt = 0
    write (MI%send_txt_fd, *, iostat=ptm_send_txt) msg
    if (ptm_send_txt .gt. 0) then
        print *, "[ptm_send] Error during write."
        close(MI%send_txt_fd)
        return
    end if
   
    close(MI%send_txt_fd)

end function



integer function ptm_recv_bin(MI, msg, dat, n)
    implicit none
    type(ptm_ptm_TunnelSet)  :: MI
    character(len=*)       :: msg
    real(8), intent(inout) :: dat(n)
    integer, intent(in)    :: n
    integer                :: i

    character(256)         :: recv_msg

    ptm_recv_bin = mbp_recv_txt(MI, recv_msg)
    if (ptm_messageCompare(msg, recv_msg) .eqv. .false.) then
        print *, "Wrong expected message. Expect ", msg, " but receive ", &
                 recv_msg
        ptm_recv_bin = 1
        return
    end if

    ptm_recv_bin = 0
    open(unit=MI%recv_bin_fd, file=MI%recv_bin_fn, form="unformatted", &
         access="stream", action="read", iostat=ptm_recv_bin,  &
         convert='LITTLE_ENDIAN')

    if (ptm_recv_bin .gt. 0) then
        print *, "ERROR OPENING RECV BIN PIPE, errcode: ", ptm_recv_bin
        close(MI%recv_bin_fd)
        return
    end if

    ptm_recv_bin = 0
    read (MI%recv_bin_fd, iostat=ptm_recv_bin) (dat(i),i=1,n,1)
    if (ptm_recv_bin .gt. 0) then
        print *, "ERROR READING RECV BIN PIPE, errcode:", ptm_recv_bin
        close(MI%recv_bin_fd)
        return
    end if

    close(MI%recv_bin_fd)
    
end function


integer function ptm_send_bin(MI, msg, dat, n)
    implicit none
    type(ptm_ptm_TunnelSet)  :: MI
    character(len=*)       :: msg
    real(8), intent(in)    :: dat(n)
    integer, intent(in)    :: n
    integer                :: i


    ptm_send_bin = mbp_send_txt(MI, msg)

    ptm_send_bin = 0
    open(unit=MI%send_bin_fd, file=MI%send_bin_fn, form="unformatted", &
         access="stream", action="write", iostat=ptm_send_bin,  &
         convert='LITTLE_ENDIAN')

    if (ptm_send_bin .gt. 0) then
        print *, "[_ptm_send_bin] Error during open."
        close(MI%send_bin_fd)
        return
    end if

    ptm_send_bin = 0
    write (MI%send_bin_fd, iostat=ptm_send_bin) (dat(i), i=1,n,1)
    if (ptm_send_bin .gt. 0) then
        print *, "[_ptm_send_bin] Error during write, err code: ", mbp_send_bin
        close(MI%send_bin_fd)
        return
    end if
   
    close(MI%send_bin_fd)

end function


subroutine ptm_hello(MI)
    implicit none
    type(ptm_ptm_TunnelSet) :: MI
    character(256) :: msg

    integer :: stat

    stat = ptm_recv_txt(MI, msg)
    if (stat .gt. 0) then
        print *, "Something went wrong during recv stage. Error io stat: ", stat
        return
    end if

    if (ptm_messageCompare(msg, "<<TEST>>")) then
        print *, "Recv hello!"
    else
        print *, len(msg), " : ", len("<<TEST>>")
        print *, "Weird msg: [", msg, "]"
    end if

    stat = ptm_send_txt(MI, "<<TEST>>")
    if (stat .gt. 0) then
        print *, "Something went wrong during send stage. Error io stat: ", stat
        return
    end if

end subroutine

logical function ptm_messageCompare(msg1, msg2)
    implicit none
    character(*) :: msg1, msg2

    if (msg1 .eq. msg2) then
        ptm_messageCompare = .true.
    else
        ptm_messageCompare = .false.
    end if

end function


end module MailboxPipeMod2
